# Reflections on Model Predictive Control Project

I found this to be a particularly challenging (& frustrating) project, as some key parts were inadequately addressed in the tutorials/ lecture, in particular IPopt and CppAD. I relied very heavily on the youtube project Q&A, and since I did not know the data format, I do not think I could have derived the coordinate transformation on my own. I'm still a bit fuzzy on psi_unity vs. psi :( 

I believe I understood the key methodology behind MPC reasonably, and just as in the case of the PID controller, I have a better appreciation of deterministic control techniques. In an ideal world, with fairly clear contraints, equations of physics (even with approximations) along with a closed loop control are very effective in controlling the motion of a vehicle. However, this project and the PID project also made me marvel at the ability of a neural network based approach to essentially learn the physics and closed loop control methodologies as was demonstrated in the Term1 behavioral cloning project.

Compared to the PID controller, which relies on three factors: current error, rate of change of current error, and historical sum of error to achieve closed loop control, MPC control relies upon a "Cost function" that can be tweaked in a nearly infinite manner to achieve control objectives. In this project the cost function relied on 7 "knobs". In more general applications, we would need to be careful that these knobs are not correlated, and an optimal choice of cost function could itself require considerable effort.

## The Model
Equations for a simple bicycle model discussed in lesson 12. The state vector that fully describes the state of the car at any point in time is a 6-dimensional vector: x and y position, angular orientation, speed, latitudinal error (cross-track error), and angular orientation error. This state vector is returned by the simulator to the control program at every timestep, along with the proximal waypoints that define the desired trajectory. In a real world application this data would be provided by the Localization module of the car (based on GPS, radar, lidar) along with Map data; the desired trajectory would be provided by the route planning module.

**Main.cpp** picks up 4 of 6 elements of the state vector from the simulator in lines 90-93. Normalized values of the two actuators used (steering angle and throttle/brake) are also picked up from the simulator in lines 101-102. The simulator feeds in waypoint locations also in the same section of code. The two remaining elements of the state vector: cross-track error and angular orientation error are calculated using the waypoints. The state vector and processed waypoint data is sent to **MPC.cpp** to calculate the actuator setting for the next few timesteps.
**Pre-processing** of waypoints involved translational and angular transformation into the car's frame of reference, and is computed in lines 112-128 of Main.cpp. A third order polynomial fit of these transformed waypoints is used by MPC.cpp to derive actuator setpoints. The **state update equations** are in lines 95-100 of MPC.cpp, and these calculate the state vector at the next timestep using a simple Newtonian motion model.

**System latency** was incorporated in lines 104-110 of Main.cpp, to handle 100ms of delay between the controller and actuator. If I set the latency to 0ms, there was considerable lateral oscillation that would become too large for any weights that were implemented in the cost function to suppress them.

The cost function used to derive optimal actuator settings is described in lines 45-58 of MPC.cpp. The largest weights (multiplier of 50,000) were used to suppress angular orientation error (epsi) and steering value (delta), and a relatively large multiplier was used to suppress changes to steering value between timesteps. The MPC.Solve method invokes the IPopt optimizer library to calculate the actuator values for the next timestep that result in the lowest possible cost given the constraints.

The MPC was tuned to enable the car to travel at speeds up to 100mph. In the beginning I started off with a total time horizon of 1sec, with 10 timesteps of 100ms duration each. At max-speed the system would calculate a set of actuator values for the next 45 meters. Given that latency was 100ms, using the same value for dt, appeared a reasonable choice to begin with. After running the simulator at multiple other settings for a number of loops, I visually observed that the mismatch between expected car location ("green line" in simulator) and the fit to the waypoints generally existed only in the first few timesteps, I nudged down N to 8 as this would also reduce computational load. I experimented with going N as low as 5, which appeared to inhibit performance (the car swung wide at turns). I nudged down dt to 80ms, which appeared to smoothen the predicted x/y position of the car. With this choice of N and dt, the MPC provides "compute coverage" of the next ~30m of the cars trajectory (0.64s at 100mph), or about 10 car-lengths-- which I believe is a reasonable distance to cover.
In the submitted code, I have dialed down the target speed to 90mph, just in case there are meaningful differences between the computer I tuned the MPC on and others.
